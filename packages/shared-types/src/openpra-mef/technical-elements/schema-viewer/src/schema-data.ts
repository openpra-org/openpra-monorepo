export interface SchemaFile {
    path: string;
    content: string;
}

export const schemaFiles: SchemaFile[] = [
  {
    "path": "data-analysis/data-analysis.ts",
    "content": "import typia, { tags } from \"typia\";\nimport { TechnicalElement, TechnicalElementTypes } from \"../technical-element\";\nimport { Named, Unique } from \"../meta\";\nimport { BasicEvent} from \"../events\";\nimport { SystemComponent, FailureMode, SuccessCriteria, UnavailabilityEvent, System } from \"../systems-analysis/systems-analysis\";\nimport { PlantOperatingStatesTable } from \"../plant-operating-state-analysis/plant-operating-state-analysis\";\n\n/**\n * Interface representing the types of parameters used in data analysis.\n * The parameter type determines the type of data analysis that can be performed.\n * The parameter type must be one of the types defined in `ParameterType` enum.\n */\nexport type ParameterType =\n    | \"FREQUENCY\"\n    | \"PROBABILITY\"\n    | \"UNAVAILABILITY\"\n    | \"CCF_PARAMETER\"\n    | \"HUMAN_ERROR_PROBABILITY\"\n    | \"OTHER\";\n\n/**\n * Enum representing the types of probability models used in data analysis.\n */\nexport enum DistributionType {\n    EXPONENTIAL = \"exponential\",\n    BINOMIAL = \"binomial\",\n    NORMAL = \"normal\",\n    LOGNORMAL = \"lognormal\",\n    WEIBULL = \"weibull\",\n    POISSON = \"poisson\",\n    UNIFORM = \"uniform\",\n    BETA = \"beta\",\n    GAMMA = \"gamma\",\n    POINT_ESTIMATE = \"point_estimate\",\n    // Add other probability models as needed\n}\n\n/**\n * Interface representing data sources and their context\n */\nexport interface DataSource {\n    /**\n     * The source of the data (e.g., \"Plant maintenance records 2020-2023\")\n     */\n    source: string;\n    /**\n     * The context or type of the data source (e.g., \"Industry standard\", \"Plant specific\")\n     */\n    context?: string;\n    /**\n     * Any additional notes about the data source\n     */\n    notes?: string;\n}\n\n/**\n * Interface representing an assumption and its context\n */\nexport interface Assumption {\n    /**\n     * The assumption statement\n     */\n    statement: string;\n    /**\n     * The context or type of the assumption (e.g., \"General\", \"Value-specific\")\n     */\n    context?: string;\n    /**\n     * Any additional notes about the assumption\n     */\n    notes?: string;\n}\n\n/**\n * Interface representing the uncertainty associated with a parameter.\n * The structure of the uncertainty changes based on the distribution type.\n */\nexport interface Uncertainty {\n    distribution: DistributionType;\n    parameters: Record<string, number>;\n    /**\n     * Sources of uncertainty in the model.\n     */\n    model_uncertainty_sources?: string[];\n}\n\n/**\n * Base Data Analysis Parameter - parent of all data analysis parameters\n * \n * This interface implements several PRA standard requirements:\n * - DA-A4: IDENTIFY the parameter to be estimated\n * - DA-A5: IDENTIFY the sources of model uncertainty, related assumptions\n * - DA-A6: IDENTIFY assumptions made due to lack of as-built details\n */\nexport interface BaseDataAnalysisParameter extends Unique, Named {\n    description?: string;\n    /**\n     * The type of parameter being analyzed.\n     * DA-A4: IDENTIFY the parameter to be estimated\n     */\n    parameterType: ParameterType;\n    /**\n     * Uncertainty information for the parameter.\n     * DA-A5: IDENTIFY the sources of model uncertainty\n     */\n    uncertainty?: Uncertainty;\n    /**\n     * All data sources used in the analysis, including both general and specific sources.\n     * DA-A4: IDENTIFY the data required for estimation\n     */\n    data_sources?: DataSource[];\n    /**\n     * All assumptions made in the analysis, including both general and specific assumptions.\n     * DA-A5: IDENTIFY the sources of model uncertainty, related assumptions\n     * DA-A6: IDENTIFY assumptions made due to lack of as-built details\n     */\n    assumptions?: Assumption[];\n}\n\n/**\n * Data Analysis parameter\n * \n * This interface implements several PRA standard requirements:\n * - DA-A2: DEFINE failure modes and success criteria\n * - DA-A3: USE an appropriate probability model for each basic event\n * - HLR-DA-B: Grouping components into a homogeneous population\n */\nexport interface DataAnalysisParameter extends BaseDataAnalysisParameter {\n    /**\n     * The estimated value for the parameter\n     */\n    value: number & tags.Minimum<0>;\n    \n    //Links to event\n    basicEventId?: string;\n    unavailabilityEventId?: string;\n\n    /**\n     * Reference to the system component this parameter is associated with.\n     * This provides access to the component's boundary and grouping information.\n     * HLR-DA-B: Grouping components into a homogeneous population\n     */\n    systemComponentId?: string;\n\n    /**\n     * Defines how the component can fail.\n     * DA-A2: DEFINE failure modes\n     */\n    failure_mode?: FailureMode;\n\n    /**\n     * Defines the criteria for success.\n     * DA-A2: DEFINE success criteria\n     */\n    success_criteria?: SuccessCriteria;\n\n    /**\n     * Represents the plant operating state for which the parameter applies.\n     * HLR-DA-B: Grouping components into a homogeneous population\n     */\n    plant_operating_state?: PlantOperatingStatesTable;\n\n    /**\n     * The probability model used to evaluate event probability.\n     * DA-A3: USE an appropriate probability model for each basic event\n     */\n    probability_model?: DistributionType;\n\n    /**\n     * Alternative approaches or parameters that could be used.\n     */\n    alternatives?: string[];\n}\n\n/**\n * Interface representing an analysis of data parameters, which is a type of technical element.\n *\n * @example\n * ```typescript\n * const analysis: DataAnalysis = {\n *   \"technical-element-type\": TechnicalElementTypes.DATA_ANALYSIS,\n *   \"technical-element-code\": \"DA\",\n *   data_parameters: [\n *     {\n *       uuid: \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",\n *       name: \"Emergency Diesel Generator Failure Rate\",\n *       description: \"Failure rate analysis for EDG-A during power operation\",\n *       parameterType: \"FREQUENCY\",\n *       value: 1.2e-5,\n *       \n *       // Component and Event References\n *       basicEventId: \"BE-EDG-FS-001\",\n *       systemComponentId: \"SYS-EDG-A\",\n *       \n *       // Failure Characteristics\n *       failure_mode: {\n *         type: \"FAILURE_TO_START\",\n *         description: \"Failure to start on demand signal\"\n *       },\n *       success_criteria: {\n *         criteria: \"Start and reach rated speed within 10 seconds\",\n *         basis: \"Technical Specifications 3.8.1\"\n *       },\n *       \n *       // Operating Context\n *       plant_operating_state: {\n *         state: \"AT_POWER\",\n *         description: \"Normal power operation\"\n *       },\n *       \n *       // Statistical Analysis\n *       probability_model: DistributionType.LOGNORMAL,\n *       uncertainty: {\n *         distribution: DistributionType.LOGNORMAL,\n *         parameters: {\n *           median: 1.2e-5,\n *           errorFactor: 3.0\n *         },\n *         model_uncertainty_sources: [\n *           \"Limited operational data\",\n *           \"Environmental factors not fully characterized\"\n *         ]\n *       },\n *       \n *       // Data Sources and Assumptions\n *       data_sources: [\n *         {\n *           source: \"Plant maintenance records 2020-2023\",\n *           context: \"Plant specific\",\n *           notes: \"Based on 156 successful starts and 2 failures\"\n *         },\n *         {\n *           source: \"NUREG/CR-6928\",\n *           context: \"Industry average\",\n *           notes: \"Used for Bayesian update\"\n *         }\n *       ],\n *       assumptions: [\n *         {\n *           statement: \"Maintenance activities restore component to as-good-as-new condition\",\n *           context: \"Reliability modeling\",\n *           notes: \"Based on comprehensive maintenance procedures\"\n *         },\n *         {\n *           statement: \"Environmental conditions remain within design basis\",\n *           context: \"Operating environment\",\n *           notes: \"Verified through environmental monitoring program\"\n *         }\n *       ],\n *       \n *       // Alternative Approaches\n *       alternatives: [\n *         \"Use of Weibull distribution for age-dependent failure modeling\",\n *         \"Incorporation of seasonal variation factors\"\n *       ]\n *     }\n *   ]\n * };\n * ```\n */\nexport interface DataAnalysis extends TechnicalElement<TechnicalElementTypes.DATA_ANALYSIS> {\n    /**\n     * Array of data analysis parameters that are part of this analysis.\n     * Each parameter represents a specific data point or measurement being analyzed.\n     */\n    data_parameters: DataAnalysisParameter[];\n}\n\n/**\n * JSON schema for validating {@link DataAnalysis} entities.\n *\n * @example\n * ```typescript\n * const isValid = DataAnalysisSchema.validate(someData);\n * ```\n */\nexport const DataAnalysisSchema = typia.json.application<[DataAnalysis], \"3.0\">();"
  },
  {
    "path": "events.ts",
    "content": "import typia, { tags } from \"typia\";\nimport { Named, Unique } from \"./meta\";\n\n// Base Event - parent of all events\nexport interface BaseEvent extends Unique, Named {\n    description?: string;\n}\n\n// Basic Event branch\nexport interface BasicEvent extends BaseEvent {\n    eventType: \"BASIC\";\n}\n\nexport interface LicensingBasisEvent extends BasicEvent {\n    eventSubType: \"LICENSING_BASIS\";\n}\n\n// Functional Event branch\nexport interface FunctionalEvent extends BaseEvent {\n    eventType: \"FUNCTIONAL\";\n}\n\nexport interface TopEvent extends FunctionalEvent {\n    eventSubtType: \"TOP\";\n}\n\n// Initiating Event branch (keeping your existing structure)\nexport interface InitiatingEvent extends BaseEvent {\n    eventType: \"INITIATING\";\n}\n\n// Schema validation\nexport const EventSchemas = {\n    base: typia.json.application<[BaseEvent], \"3.0\">(),\n    basic: typia.json.application<[BasicEvent], \"3.0\">(),\n    licensing: typia.json.application<[LicensingBasisEvent], \"3.0\">(),\n    functional: typia.json.application<[FunctionalEvent], \"3.0\">(),\n    top: typia.json.application<[TopEvent], \"3.0\">(),\n    initiating: typia.json.application<[InitiatingEvent], \"3.0\">()\n} as const;"
  },
  {
    "path": "initiating-event-analysis/initiating-event-analysis.ts",
    "content": "import typia, { tags } from \"typia\";\n\nimport { TechnicalElement, TechnicalElementTypes } from \"../technical-element\";\nimport { Named, Unique } from \"../meta\";\n\n/**\n * Interface representing an initiating event, which is both unique and named.\n *\n * @example\n * ```\n * const event: InitiatingEvent = {\n *   uuid: \"123e4567-e89b-12d3-a456-426614174000\",\n *   name: \"Loss of Offsite Power\",\n *   frequency: 1.2e-7\n * };\n * ```\n */\nexport interface InitiatingEvent extends Unique, Named {\n  /**\n   * The frequency of the initiating event. The frequency must be a non-negative number.\n   *\n   * @remarks\n   * The frequency definition here is incomplete because it does not specify a period.\n   *\n   * @example\n   * ```\n   * const frequency: number = 1.2e-7\n   * ```\n   */\n  frequency: number & tags.Minimum<0>;\n}\n\n/**\n * Interface representing an analysis of initiating events, which is a type of technical element.\n *\n * @example\n * ```\n * const analysis: InitiatingEventsAnalysis = {\n *   \"technical-element-type\": TechnicalElementTypes.INITIATING_EVENT_ANALYSIS,\n *   initiating_events: [\n *     {\n *       uuid: \"123e4567-e89b-12d3-a456-426614174000\",\n *       name: \"Event Name\",\n *       frequency: 1.2e-7\n *     }\n *     {\n *       uuid: \"223e4567-e89b-12d3-a456-426614174001\",\n *       name: \"Steam Generator Tube Rupture\",\n *       frequency: 1.0e-6\n *     }\n *   ]\n * };\n * ```\n */\nexport interface InitiatingEventsAnalysis extends TechnicalElement<TechnicalElementTypes.INITIATING_EVENT_ANALYSIS> {\n  initiating_events: InitiatingEvent[];\n}\n\n/**\n * JSON schema for validating {@link InitiatingEventsAnalysis} entities.\n *\n * @example\n * ```\n * const isValid = InitiatingEventsAnalysisSchema.validate(someData);\n * ```\n */\nexport const InitiatingEventsAnalysisSchema = typia.json.application<[InitiatingEventsAnalysis], \"3.0\">();\n"
  },
  {
    "path": "meta.ts",
    "content": "import typia, { tags } from \"typia\";\n\n/**\n * Interface representing a unique entity with a UUID.\n *\n * @example\n * ```\n * const uniqueEntity: Unique = {\n *   uuid: \"123e4567-e89b-12d3-a456-426614174000\"\n * };\n * ```\n */\nexport interface Unique {\n  uuid: tags.Format<\"uuid\">;\n}\n\n/**\n * Interface representing an entity with a name.\n *\n * @example\n * ```\n * const namedEntity: Named = {\n *   name: \"Sample Name\"\n * };\n * ```\n */\nexport interface Named {\n  name: string;\n}\n\n/**\n * JSON schema for validating {@link Unique} entities.\n *\n * @example\n * ```\n * const isValid = UniqueTagSchema.validate(someData);\n * ```\n */\nexport const UniqueTagSchema = typia.json.application<[Unique], \"3.0\">();\n\n/**\n * JSON schema for validating {@link Named} entities.\n *\n * @example\n * ```\n * const isValid = NamedTagSchema.validate(someData);\n * ```\n */\nexport const NamedTagSchema = typia.json.application<[Named], \"3.0\">();\n"
  },
  {
    "path": "plant-operating-state-analysis/plant-operating-state-analysis.ts",
    "content": "import typia from \"typia\";\nimport { TechnicalElement, TechnicalElementTypes } from \"../technical-element\";\nimport { Unique } from \"../meta\";\n\n/**\n * Interface representing a single plant operating state entry\n * \n * @example\n * ```\n * const entry: StateField = {\n *   state: \"Maintenance\",\n *   duration: 240 // hours\n * };\n * ```\n */\ninterface StateField {\n  /** \n   * The name/identifier of the operating state\n   * @pattern ^[A-Za-z ]+$  // Enforces alphabetical characters and spaces\n   */\n  state: string;\n\n  /**\n   * Duration in hours for this state\n   * @minimum 0  // Ensures non-negative values\n   */\n  duration: number;\n}\n\n/**\n * Interface representing a table of plant operating states, which is unique.\n * Improved type safety for state_fields using StateField interface.\n * \n * @example\n * ```\n * const table: PlantOperatingStatesTable = {\n *   uuid: \"123e4567-e89b-12d3-a456-426614174000\",\n *   state_fields: [\n *     { state: \"Normal Operation\", duration: 8760 },\n *     { state: \"Shutdown\", duration: 720 }\n *   ]\n * };\n * ```\n */\nexport interface PlantOperatingStatesTable extends Unique {\n  /**\n   * Array of validated state entries\n   * @minItems 1  // Requires at least one state entry\n   */\n  state_fields: StateField[];\n}\n\n/**\n * Interface representing an analysis of plant operating states with strict typing.\n * Now uses properly typed PlantOperatingStatesTable for states property.\n * \n * @example\n * ```\n * const analysis: PlantOperatingStatesAnalysis = {\n *   \"technical-element-type\": TechnicalElementTypes.PLANT_OPERATING_STATES_ANALYSIS,\n *   states: {\n *     uuid: \"123e4567-e89b-12d3-a456-426614174000\",\n *     state_fields: [\n *       { state: \"Normal Operation\", duration: 8760 },\n *       { state: \"Shutdown\", duration: 720 }\n *     ]\n *   }\n * };\n * ```\n */\nexport interface PlantOperatingStatesAnalysis\n  extends TechnicalElement<TechnicalElementTypes.PLANT_OPERATING_STATES_ANALYSIS> {\n  /** Validated operating states container */\n  states: PlantOperatingStatesTable;\n}\n\n/**\n * JSON schema for validating {@link PlantOperatingStatesAnalysis} entities.\n * Now includes validation for nested StateField structure through type inheritance.\n * \n * @example\n * ```\n * const isValid = PlantOperatingStatesAnalysisSchema.validate(someData);\n * ```\n */\nexport const PlantOperatingStatesAnalysisSchema = typia.json.application<[PlantOperatingStatesAnalysis], \"3.0\">(); "
  },
  {
    "path": "systems-analysis/systems-analysis.ts",
    "content": "import { Unique, Named } from \"../meta\";\nimport { PlantOperatingStatesTable } from \"../plant-operating-state-analysis/plant-operating-state-analysis\";\n\n/**\n * Interface representing a system.\n */\nexport interface System extends Unique, Named {\n    description?: string;\n    components: SystemComponent[];\n    plantOperatingStates: PlantOperatingStatesTable;\n}\n\n/**\n * Interface representing a component within a system.\n */\nexport interface SystemComponent extends Unique, Named {\n    description?: string;\n    /**\n     * Defines the structure, system, and component (SSC) boundaries.\n     * This includes physical and functional boundaries of the component.\n     */\n    boundary?: string;\n    /**\n     * Grouping of components for analysis purposes.\n     * Used to categorize components with similar characteristics or functions.\n     */\n    component_group?: string;\n    systemId: string; //Refers to the System.uuid\n    failureModes: FailureMode[];\n    successCriteria: SuccessCriteria[];\n    unavailabilityEvents: UnavailabilityEvent[];\n}\n\n/**\n * Interface representing a failure mode of a component.\n */\nexport interface FailureMode extends Unique, Named {\n    description?: string;\n     componentId: string; //Refers to SystemComponent.uuid\n}\n\n/**\n * Interface representing the success criteria for a component or system.\n */\nexport interface SuccessCriteria extends Unique, Named {\n    description?: string;\n    componentId?: string; //Refers to SystemComponent.uuid\n    systemId?: string;  //Refers to the System.uuid\n}\n\n\n/**\n * Interface representing an unavailability event.\n * The  UnavailabilityEvent is not about the start of an event sequence like the InitiatingEvent, \n * or a functional failure like a FunctionalEvent, but instead is related to a system's \n * reliability and its possible states, which need to be accounted for within the system modelling\n */\nexport interface UnavailabilityEvent extends Unique, Named {\n    description?: string;\n    componentId: string; //Refers to SystemComponent.uuid\n}\n"
  },
  {
    "path": "technical-element.ts",
    "content": "import typia from \"typia\";\n\n/**\n * Mapping of technical element codes to their full names\n * \n * @remarks\n * This constant provides a mapping between abbreviated codes and their corresponding\n * full technical element names. The codes adhere to the latest ANS standards.\n */\nexport const TECHNICAL_ELEMENT_CODES = {\n  'POS': 'PLANT_OPERATING_STATE_ANALYSIS',\n  'IE': 'INITIATING_EVENT_ANALYSIS',\n  'ES': 'EVENT_SEQUENCE_ANALYSIS',\n  'SC': 'SUCCESS_CRITERIA_DEVELOPMENT',\n  'SY': 'SYSTEMS_ANALYSIS',\n  'HRA': 'HUMAN_RELIABILITY_ANALYSIS',\n  'DA': 'DATA_ANALYSIS',\n  'ESQ': 'EVENT_SEQUENCE_QUANTIFICATION',\n  'MS': 'MECHANISTIC_SOURCE_TERM_ANALYSIS',\n  'RC': 'RADIOLOGICAL_CONSEQUENCE_ANALYSIS',\n  'RI': 'RISK_INTEGRATION',\n  'FL': 'INTERNAL_FLOOD_PRA',\n  'F': 'INTERNAL_FIRE_PRA',\n  'S': 'SIESMIC_PRA',\n  'HS': 'HAZARDS_SCREENING_ANALYSIS',\n  'W': 'HIGH WINDS PRA',\n  'XF': 'EXTERNAL_FLOODING_PRA',\n  'O': 'OTHER_HAZARDS_PRA',\n  'UNK': 'UNKNOWN'\n} as const;\n\n/**\n * Type representing valid technical element codes\n */\nexport type TechnicalElementCode = keyof typeof TECHNICAL_ELEMENT_CODES;\n\n\n/**\n * Enum representing the types of PRA (Probabilistic Risk Assessment) technical elements.\n * @remarks\n * Each type corresponds to a specific analysis or assessment category.\n * The values are kebab-case strings for API compatibility.\n * \n * @example\n * ```\n * const type: TechnicalElementTypes = TechnicalElementTypes.PLANT_OPERATING_STATES_ANALYSIS;\n * ```\n */\nexport enum TechnicalElementTypes {\n  UNKNOWN = \"unknown\",\n  PLANT_OPERATING_STATES_ANALYSIS = \"plant-operating-states-analysis\",\n  INITIATING_EVENT_ANALYSIS = \"initiating-event-analysis\",\n  EVENT_SEQUENCE_ANALYSIS = \"event-sequence-analysis\",\n  SUCCESS_CRITERIA_DEVELOPMENT = \"success-criteria-development\",\n  SYSTEMS_ANALYSIS = \"systems-analysis\",\n  HUMAN_RELIABILITY_ANALYSIS = \"human-reliability-analysis\",\n  DATA_ANALYSIS = \"data-analysis\",\n  EVENT_SEQUENCE_QUANTIFICATION = \"event-sequence-quantification\",\n  MECHANISTIC_SOURCE_TERM_ANALYSIS = \"mechanistic-source-term-analysis\",\n  CONSEQUENCE_ANALYSIS = \"consequence-analysis\",\n  RISK_INTEGRATION = \"risk-integration\",\n  INTERNAL_FLOOD_PRA = \"internal-flood-pra\",\n  INTERNAL_FIRE_PRA = \"internal-fire-pra\",\n  SEISMIC_PRA = \"seismic-pra\",\n  HAZARDS_SCREENING_ANALYSIS = \"hazards-screening-analysis\",\n  HIGH_WINDS_PRA = \"high-winds-pra\",\n  EXTERNAL_FLOODING_PRA = \"external-flooding-pra\",\n  OTHER_HAZARDS_PRA = \"other-hazards-pra\"\n}\n\n/**\n * Interface representing a technical element with a specific type and code.\n *@remarks\n * This interface defines the structure of a technical element in the system.\n * It includes both the full type and the abbreviated code for the element.\n * @typeparam TechnicalElementType - The type of the technical element.\n *\n * @example\n * ```typescript\n *    const element: TechnicalElement<TechnicalElementTypes> = {\n *   \"technical-element-type\": TechnicalElementTypes.DATA_ANALYSIS,\n *   \"technical-element-code\": \"DA\"\n * };\n */\nexport interface TechnicalElement<TechnicalElementType> {\n  \"technical-element-type\": TechnicalElementType;\n  \"technical-element-code\": TechnicalElementCode;\n}\n\n/**\n * JSON schema for validating {@link TechnicalElementTypes}.\n * @remarks\n * This schema is generated using typia and provides runtime validation\n * for technical element types. It ensures that only valid enum values\n * are used throughout the application.\n * @example\n * ```\n * const isValid = TechnicalElementTypesSchema.validate(someData);\n * ```\n */\nexport const TechnicalElementTypesSchema = typia.json.application<[TechnicalElementTypes], \"3.0\">();\n\n/**\n * Runtime validation for technical elements\n * \n * @remarks\n * Provides runtime type checking for technical elements including both\n * their type and code. This ensures data consistency throughout the application.\n */\nexport const validateTechnicalElement = typia.createValidate<TechnicalElement<TechnicalElementTypes>>();\n\n/**\n * Type guard for technical elements\n * \n * @remarks\n * A type guard function that checks if a given object is a valid technical element.\n * This is useful for runtime type checking and validation.\n */\nexport const isTechnicalElement = typia.createIs<TechnicalElement<TechnicalElementTypes>>();\n"
  }
];